!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
AcquireLikeParams	input_like.c	/^int AcquireLikeParams(struct KeyValue *kv, LikeParams *parameters)$/;"	f
AcquireMCMCParams	input_mcmc.c	/^int AcquireMCMCParams(struct KeyValue *kv, int *model, int *n_iter, double eta[], double tune[])$/;"	f
AcquireTreeParams	input_sim.c	/^int AcquireTreeParams(struct KeyValue *kv, TreeParams *parameters)$/;"	f
AddBranchLengths	tree_funcs.c	/^void AddBranchLengths(TreeNode *p, double lengths[2][2])$/;"	f
AssignBranchLengths	label.c	/^void AssignBranchLengths(TreeNode *p)$/;"	f
AssignBranchLengthsBackwards	tree_funcs.c	/^void AssignBranchLengthsBackwards(TreeNode *p)$/;"	f
AssignMCMCModel	likelihood-sdd.c	/^void AssignMCMCModel(int model, double rates[], TreeParams *parameters)$/;"	f
AssignNodeTimes	label.c	/^void AssignNodeTimes(TreeNode *p)$/;"	f
AssignRootState	build.c	/^int AssignRootState(TreeNode *root, TreeParams *parameters)$/;"	f
AssignTransitionProbs	tree_funcs.c	/^void AssignTransitionProbs(TreeNode *p, double alpha, double beta)$/;"	f
AvgBranchLength_obj	Makefile	/^AvgBranchLength_obj = AvgBranchLength.o read_tree.o label.o nodes.o report.o extra.o$/;"	m
BackUp	build.c	/^void BackUp(TreeNode *root, TreeNode *here, TreeParams *parameters)$/;"	f
BackUp2Regions	build_2regions.c	/^void BackUp2Regions(TreeNode *root, TreeNode *here, TreeParams *parameters)$/;"	f
BackUpCheck	buildcheck.c	/^void BackUpCheck(TreeNode *root, TreeNode *here, TreeParams *parameters, BranchNode *checknode, int *tips_so_far)$/;"	f
BackUpCount	buildcheck.c	/^void BackUpCount(TreeNode *root, TreeNode *here, TreeParams *parameters, int *tips_so_far)$/;"	f
BackUpFinal	buildcheck.c	/^void BackUpFinal(TreeNode *here)$/;"	f
BirthDeath	build.c	/^void BirthDeath(TreeNode *root, TreeNode *here, int direction, TreeParams *parameters)$/;"	f
BirthDeath2Regions	build_2regions.c	/^void BirthDeath2Regions(TreeNode *root, TreeNode *here, int where, int direction, TreeParams *parameters)$/;"	f
BirthDeathCheck	buildcheck.c	/^void BirthDeathCheck(TreeNode *root, TreeNode *here, int direction, TreeParams *parameters, BranchNode *checknode, int *tips_so_far)$/;"	f
BirthDeathCount	buildcheck.c	/^void BirthDeathCount(TreeNode *root, TreeNode *here, int direction, TreeParams *parameters, int *tips_so_far)$/;"	f
BranchNode	nodes.h	/^} BranchNode;$/;"	t
BreakTree	likelihood-sdd.c	/^void BreakTree(TreeNode *p, BranchNode *branches[])$/;"	f
BuildTree2Regions	build_2regions.c	/^void BuildTree2Regions(TreeNode *root, TreeParams *parameters)$/;"	f
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -g -O2 -std=gnu99$/;"	m
CalcPostProb	tree_funcs.c	/^void CalcPostProb(TreeNode *p, double alpha, double beta)$/;"	f
ChangeFileSuffix	extra.c	/^void ChangeFileSuffix(char inname[], char oldend[], char newend[], char outname[])$/;"	f
CompositePruneTree_obj	Makefile	/^CompositePruneTree_obj = CompositePruneTree.o read_tree.o label.o nodes.o output.o report.o extra.o copy.o build.o randist.o prune.o$/;"	m
CondLikeDn	tree_funcs.c	/^void CondLikeDn(TreeNode *p)$/;"	f
CondLikeUp	tree_funcs.c	/^void CondLikeUp(TreeNode *p, TreeNode *r)$/;"	f
CopyNode	copy.c	/^void CopyNode(TreeNode *old, TreeNode *new)$/;"	f
CopyTree	copy.c	/^TreeNode *CopyTree(TreeNode *oldroot)$/;"	f
CopyTreeGuts	copy.c	/^void CopyTreeGuts(TreeNode *p, TreeNode *q)$/;"	f
CountNodeChanges	EstimateBeta.c	/^void CountNodeChanges(TreeNode *p, int *counter1, int *counter2)$/;"	f
CountNodeTraits	tree_funcs.c	/^void CountNodeTraits(TreeNode *p, int counter[2])$/;"	f
CountNodes	tree_funcs.c	/^void CountNodes(TreeNode *p, int *counter)$/;"	f
CountTipStates	report.c	/^void CountTipStates(TreeNode *p, int tip_counter[])$/;"	f
CountTipTraits	tree_funcs.c	/^void CountTipTraits(TreeNode *p, int counter[2])$/;"	f
CountTips	report.c	/^void CountTips(TreeNode *p, int *counter)$/;"	f
CountTips_obj	Makefile	/^CountTips_obj = CountTips.o read_tree.o label.o nodes.o report.o extra.o$/;"	m
Dex	output.c	/^int Dex(TreeNode *p)$/;"	f
DownhillSimplex	simplex.c	/^double DownhillSimplex(double simplex[][MAX_PARAM], double y[], double (*func)(TreeInfo *, double []), TreeInfo *tree)$/;"	f
EstimateBeta_obj	Makefile	/^EstimateBeta_obj = EstimateBeta.o read_tree.o label.o nodes.o report.o extra.o$/;"	m
FillTipArray	PruneTree2.c	/^void FillTipArray(TreeNode *p, TreeNode *tips[])$/;"	f
FreeBranch	nodes.c	/^void FreeBranch(BranchNode *p)$/;"	f
FreeBranchNode	nodes.c	/^void FreeBranchNode(BranchNode *p)$/;"	f
FreeLikeParams	input_like.c	/^void FreeLikeParams(LikeParams *params)$/;"	f
FreeNode	nodes.c	/^TreeNode *FreeNode(TreeNode *here)$/;"	f
FreeSimTree1Info	likelihood-sdd.c	/^void FreeSimTree1Info(SimTree1Info *p)$/;"	f
FreeTree	nodes.c	/^void FreeTree(TreeNode *p)$/;"	f
FreeTreeInfo	nodes.c	/^void FreeTreeInfo(TreeInfo *tree)$/;"	f
FreeTreeParams	input_sim.c	/^void FreeTreeParams(TreeParams *params)$/;"	f
Get2Like_obj	Makefile	/^Get2Like_obj = Get2Like.o build.o buildcheck.o extra.o input_sim.o label.o likelihood-sdd.o nodes.o randist.o read_tree.o report.o output.o output_like.o keyvalue.o$/;"	m
GetAncStates	reconstruct.c	/^void GetAncStates(TreeNode *p, double rates[], FILE *fp)$/;"	f
GetBranchLengths	report.c	/^void GetBranchLengths(TreeNode *p, double lengths[])$/;"	f
GetCL0	likelihood.c	/^double GetCL0(TreeNode *p, double rates[])$/;"	f
GetCL1	likelihood.c	/^double GetCL1(TreeNode *p, double rates[])$/;"	f
GetDownPassSequence	tree_funcs.c	/^void GetDownPassSequence(TreeNode *p, int *i)$/;"	f
GetNeeNegLogL	likelihood.c	/^double GetNeeNegLogL(TreeInfo *tree, double rates[])$/;"	f
GetNextBD	build.c	/^double GetNextBD(TreeNode *p, TreeParams *parameters, double *t)$/;"	f
GetNextBDCheck	buildcheck.c	/^double GetNextBDCheck(TreeNode *p, TreeParams *parameters, double *t, BranchNode *checknode, int direction)$/;"	f
GetNodeAges1	NodeAges.c	/^void GetNodeAges1(TreeNode *p, double total_tip_lengths[], int total_node_depth[])$/;"	f
GetNodeAges2	NodeAges.c	/^void GetNodeAges2(TreeNode *p, double *total_tip_length, double *total_node_time)$/;"	f
GetNodeDepth	report.c	/^void GetNodeDepth(TreeNode *p, int depths[])$/;"	f
GetNodeTimes	report.c	/^void GetNodeTimes(TreeNode *p, double times[])$/;"	f
GetOneTipProb	likelihood-sdd.c	/^void GetOneTipProb(BranchNode *b, TreeParams *parameters, int s1, int nonextinct)$/;"	f
GetPrunedNegLogL	likelihood.c	/^double GetPrunedNegLogL(TreeInfo *tree, double rates[])$/;"	f
GetSDDLogL	likelihood-sdd.c	/^double GetSDDLogL(TreeInfo *tree, double rates[], int model)$/;"	f
GetSegProb	likelihood-sdd.c	/^void GetSegProb(BranchNode *b, TreeParams *parameters, int s1)$/;"	f
GetSurvProbs	likelihood-sdd.c	/^void GetSurvProbs(TreeInfo *tree, TreeParams *parameters)$/;"	f
GetTipStates	report.c	/^void GetTipStates(TreeNode *p, int states[])$/;"	f
KV_FLOATERR	keyvalue.h	11;"	d
KV_INTERR	keyvalue.h	10;"	d
KV_MAXPARMS	keyvalue.h	9;"	d
KeyValue	keyvalue.h	/^struct KeyValue$/;"	s
KeyValueaddparm	keyvalue.c	/^void KeyValueaddparm(struct KeyValue *p, const char *key, const char *value)$/;"	f
KeyValuekeyindex	keyvalue.c	/^int KeyValuekeyindex(const struct KeyValue *p, const char *key)$/;"	f
LDFLAGS	Makefile	/^LDFLAGS = -lm$/;"	m
LIKEPLOTSIZE	output_like.h	12;"	d
LabelInteriorNodes	label.c	/^void LabelInteriorNodes(TreeNode *p)$/;"	f
LabelTips	label.c	/^void LabelTips(TreeNode *p)$/;"	f
LikeParams	input_like.h	/^} LikeParams;$/;"	t
MAX_NODES	likelihood.h	10;"	d
MAX_PARAM	amoeba.h	14;"	d
MAX_PARAM	simplex.h	14;"	d
MAX_VERT	amoeba.h	15;"	d
MAX_VERT	simplex.h	15;"	d
MCMC_obj	Makefile	/^SDD-MCMC_obj = SDD-MCMC.o build.o buildcheck.o extra.o input_like.o input_mcmc.o input_sim.o keyvalue.o label.o likelihood-sdd.o nodes.o output.o output_like.o randist.o read_tree.o report.o$/;"	m
MakeLikePlot	output_like.c	/^void MakeLikePlot(TreeInfo *tree, double total_loglike[][LIKEPLOTSIZE], double (*likefunc)(TreeInfo *, double []))$/;"	f
MoveRoot	build.c	/^TreeNode *MoveRoot(TreeNode *root)$/;"	f
NewBranchNode	nodes.c	/^BranchNode *NewBranchNode()$/;"	f
NewLikeParams	input_like.c	/^LikeParams *NewLikeParams()$/;"	f
NewNode	nodes.c	/^TreeNode *NewNode(TreeNode *ancestor, double t)$/;"	f
NewSimTree1Info	likelihood-sdd.c	/^SimTree1Info *NewSimTree1Info()$/;"	f
NewTreeInfo	nodes.c	/^TreeInfo *NewTreeInfo()$/;"	f
NewTreeParams	input_sim.c	/^TreeParams *NewTreeParams()$/;"	f
NodeAges_obj	Makefile	/^NodeAges_obj = NodeAges.o read_tree.o label.o nodes.o output.o report.o extra.o copy.o build.o randist.o prune.o$/;"	m
OpenFixedLikeFile	output_like.c	/^FILE *OpenFixedLikeFile(LikeParams *parameters)$/;"	f
OpenMLFile	output_like.c	/^FILE *OpenMLFile(LikeParams *parameters)$/;"	f
OutputTreeToFile	tree_funcs.c	/^void OutputTreeToFile(TreeNode *p, FILE *fp)$/;"	f
PassDownTree	tree_funcs.c	/^void PassDownTree(TreeNode *p)$/;"	f
PassUpTree	tree_funcs.c	/^void PassUpTree(TreeNode *p)$/;"	f
PrintBranches	output_like.c	/^void PrintBranches(BranchNode *branches[], int n_branches)$/;"	f
PrintMessage	output.c	/^void PrintMessage(char *message, int verb_level)$/;"	f
PrintNode	tree_funcs.c	/^void PrintNode(TreeNode *here)$/;"	f
PruneTree	prune.c	/^void PruneTree(TreeNode *p, int where)$/;"	f
PruneTree2_obj	Makefile	/^PruneTree2_obj = PruneTree2.o read_tree.o label.o nodes.o output.o report.o extra.o copy.o build.o randist.o prune.o$/;"	m
PruneTree_obj	Makefile	/^PruneTree_obj = PruneTree.o read_tree.o label.o nodes.o output.o report.o extra.o copy.o build.o randist.o prune.o$/;"	m
PruningCL	likelihood.c	/^void PruningCL(TreeNode *p, double rates[])$/;"	f
PutInteriorNodeStates	read_tree.c	/^void PutInteriorNodeStates(TreeNode *p, int states[])$/;"	f
PutTipStates	read_tree.c	/^void PutTipStates(TreeNode *p, int states[])$/;"	f
RandomNumber	tree_funcs.c	/^double RandomNumber (long int *seed)$/;"	f
ReadTree	read_tree.c	/^TreeNode *ReadTree(char *filename)$/;"	f
ReadTreeString	read_tree.c	/^void ReadTreeString(TreeNode *root, char *tree_string)$/;"	f
ReconstructAncestors	reconstruct.c	/^void ReconstructAncestors(TreeInfo *tree, double rates[], int fixed)$/;"	f
RemoveTip	PruneTree2.c	/^void RemoveTip(TreeNode *p)$/;"	f
ReportFixedLike	output_like.c	/^void ReportFixedLike(FILE *fp, double loglike, TreeInfo *tree)$/;"	f
ReportML	output_like.c	/^void ReportML(FILE *fp, double loglike, TreeInfo *tree, int niter, double rates[])$/;"	f
SetUpTree	tree_funcs.c	/^void SetUpTree(int numTaxa)$/;"	f
ShowParamValues	output.c	/^void ShowParamValues(TreeParams *parameters)$/;"	f
ShowRootMove	output.c	/^void ShowRootMove(int report)$/;"	f
ShowRootState	output.c	/^void ShowRootState(int report)$/;"	f
ShowTree	output.c	/^void ShowTree(TreeNode *p)$/;"	f
ShowTreeDiscard	output.c	/^void ShowTreeDiscard(TreeParams *parameters)$/;"	f
ShowTreeIndent	output.c	/^void ShowTreeIndent(TreeNode *p, int indent)$/;"	f
ShowTreeParentheses	output.c	/^void ShowTreeParentheses(TreeNode *p)$/;"	f
SimTree1	likelihood-sdd.c	/^void SimTree1(TreeParams *parameters, BranchNode *bnode, int start_trait, int check, SimTree1Info *siminfo)$/;"	f
SimTree1Info	likelihood-sdd.h	/^} SimTree1Info;$/;"	t
SimTreeSDD_obj	Makefile	/^SimTreeSDD_obj = SimTreeSDD.o build.o build_2regions.o keyvalue.o label.o nodes.o input_sim.o output.o randist.o report.o$/;"	m
SumBranchRates	EstimateBeta.c	/^void SumBranchRates(TreeNode *p, double *ratesum)$/;"	f
TINY	input_like.h	11;"	d
TOO_BIG	build.h	12;"	d
TempCountTips	CountTest.c	/^void TempCountTips(TreeNode *p, int *counter, double end_t)$/;"	f
TempSimTree1	CountTest.c	/^TreeNode *TempSimTree1(TreeParams *parameters, BranchNode *bnode, int start_trait, int check, SimTree1Info *siminfo)$/;"	f
TransitionProb	likelihood.c	/^double TransitionProb(int from, int to, double time, double rates[])$/;"	f
TreeInfo	nodes.h	/^} TreeInfo;$/;"	t
TreeLike_obj	Makefile	/^TreeLike_obj = TreeLike.o read_tree.o input_like.o keyvalue.o label.o likelihood.o nodes.o output_like.o output.o simplex.o report.o extra.o reconstruct.o$/;"	m
TreeNode	nodes.h	/^} TreeNode;$/;"	t
TreeParams	input_sim.h	/^} TreeParams;$/;"	t
UNDEF	extra.h	8;"	d
UnMarkAllNodes	tree_funcs.c	/^void UnMarkAllNodes(TreeNode *p)$/;"	f
Wait2RegionEvent	build_2regions.c	/^int Wait2RegionEvent(int *where, double now, double *wait_t, TreeParams *parameters)$/;"	f
WriteBMSTraitFile	output.c	/^void WriteBMSTraitFile(TreeNode *p, char *prefix, int n_tips, int states[])$/;"	f
WriteNewickFile	output.c	/^void WriteNewickFile(TreeNode *p, char *prefix)$/;"	f
WriteNewickTree	output.c	/^void WriteNewickTree(TreeNode *p, FILE *fp)$/;"	f
WriteNexusFile	output.c	/^void WriteNexusFile(TreeNode *p, char *prefix, int n_tips, int states[], TreeParams *parameters)$/;"	f
WriteNexusTree	output.c	/^void WriteNexusTree(TreeNode *p, FILE *fp)$/;"	f
WriteTTNFile	output.c	/^void WriteTTNFile(TreeNode *p, char *prefix)$/;"	f
WriteTTNNodes	output.c	/^void WriteTTNNodes(TreeNode *p, FILE *fp)$/;"	f
WriteTTNTips	output.c	/^void WriteTTNTips(TreeNode *p, FILE *fp)$/;"	f
WriteTotalLikeFile	output_like.c	/^void WriteTotalLikeFile(double total_loglike[][LIKEPLOTSIZE], LikeParams *parameters)$/;"	f
__AMOEBA_H__	amoeba.h	8;"	d
__BUILDCHECK_H__	buildcheck.h	7;"	d
__BUILDREGION_H__	build_2regions.h	6;"	d
__BUILD_H__	build.h	6;"	d
__COPY_H__	copy.h	6;"	d
__EXTRA_H__	extra.h	6;"	d
__INPUTLIKE_H__	input_like.h	9;"	d
__INPUTMCMC_H__	input_mcmc.h	9;"	d
__INPUT_H__	input_sim.h	9;"	d
__KEYVALUE__	keyvalue.h	7;"	d
__LABEL_H__	label.h	9;"	d
__LIKELIHOODSDD_H__	likelihood-sdd.h	6;"	d
__LIKELIHOOD_H__	likelihood.h	5;"	d
__NODES_H__	nodes.h	2;"	d
__OUTPUTLIKE_H__	output_like.h	6;"	d
__OUTPUT_H__	output.h	9;"	d
__PRUNE_H__	prune.h	6;"	d
__RANDIST_H__	randist.h	6;"	d
__READTREE_H__	read_tree.h	8;"	d
__RECONSTRUCT_H__	reconstruct.h	5;"	d
__REPORT_H__	report.h	5;"	d
__SIMPLEX_H__	simplex.h	8;"	d
amoeba	amoeba.c	/^double amoeba (double p[][MAX_PARAM], double y[], double (*funk)(TreeInfo *, double []), TreeInfo *tree)$/;"	f
amotry	amoeba.c	/^static double amotry (double p[][MAX_PARAM], double y[], double psum[], $/;"	f	file:
anc	nodes.h	/^	struct tnode *left, *right, *anc;$/;"	m	struct:tnode
birth	input_sim.h	/^	double birth[2];			\/\/ speciation rates$/;"	m
bnode	nodes.h	/^typedef struct bnode$/;"	s
branches	nodes.h	/^	BranchNode **branches;	\/\/ ditto for an array of broken branches$/;"	m
cl	nodes.h	/^	double cl[2];			\/\/ conditional likelihoods$/;"	m	struct:tnode
compare_branchtimes	extra.c	/^int compare_branchtimes(const void *a, const void *b)$/;"	f
compare_doubles	extra.c	/^int compare_doubles(const void *a, const void *b)$/;"	f
death	input_sim.h	/^	double death[2];			\/\/ extinction rates$/;"	m
deleteKeyValue	keyvalue.c	/^void deleteKeyValue(struct KeyValue *p)$/;"	f
downPassSequence	tree_funcs.h	/^TreeNode *nodes, **downPassSequence;$/;"	v
end_t	input_sim.h	/^	double end_t;				\/\/ time for which to run the tree$/;"	m
end_t	nodes.h	/^	double end_t;			\/\/ time of tips$/;"	m
exponential_distribution	randist.c	/^double exponential_distribution(double lambda)$/;"	f
factorial	tree_funcs.c	/^unsigned long int factorial(int n)$/;"	f
file_prefix	input_sim.h	/^	char file_prefix[128];		\/\/ prefix to give output files$/;"	m
ftol	amoeba.c	/^const double ftol = 1.0e-16;$/;"	v
ftol	simplex.c	/^const double ftol = 1.0e-10;$/;"	v
geometric_distribution	tree_funcs.c	/^long int geometric_distribution(double p)$/;"	f
getKeyValuedouble	keyvalue.c	/^double getKeyValuedouble(const struct KeyValue *p, const char *key)$/;"	f
getKeyValueint	keyvalue.c	/^int getKeyValueint(const struct KeyValue *p, const char *key)$/;"	f
getKeyValuestring	keyvalue.c	/^const char *getKeyValuestring(const struct KeyValue *p, const char *key)$/;"	f
get_psum	amoeba.c	/^static void get_psum (double p[][MAX_PARAM], double psum[], int n_param)$/;"	f	file:
get_simsum	simplex.c	/^static void get_simsum (double simplex[][MAX_PARAM], double simsum[], int n_param)$/;"	f	file:
index	nodes.h	/^	int index, trait;$/;"	m	struct:tnode
intNodeNum	label.c	/^int intNodeNum;$/;"	v
key	keyvalue.h	/^	char *key[KV_MAXPARMS];$/;"	m	struct:KeyValue
left	nodes.h	/^	struct tnode *left, *right, *anc;$/;"	m	struct:tnode
length	nodes.h	/^	double time, length;$/;"	m	struct:tnode
like_func	input_like.h	/^	int like_func;$/;"	m
loadKeyValue	keyvalue.c	/^struct KeyValue *loadKeyValue(const char *filename)$/;"	f
main	AvgBranchLength.c	/^int main(int argc, char *argv[])$/;"	f
main	CompositePruneTree.c	/^int main(int argc, char *argv[])$/;"	f
main	CountTest.c	/^int main(int argc, char *argv[])$/;"	f
main	CountTips.c	/^int main(int argc, char *argv[])$/;"	f
main	EstimateBeta.c	/^int main(int argc, char *argv[])$/;"	f
main	Get2Like.c	/^int main(int argc, char *argv[])$/;"	f
main	NodeAges.c	/^int main(int argc, char *argv[])$/;"	f
main	PruneTree.c	/^int main(int argc, char *argv[])$/;"	f
main	PruneTree2.c	/^int main(int argc, char *argv[])$/;"	f
main	SDD-MCMC.c	/^int main(int argc, char *argv[])$/;"	f
main	SimTree2Regions.c	/^int main(int argc, char *argv[])$/;"	f
main	SimTreeSDD.c	/^int main(int argc, char *argv[])$/;"	f
main	TreeLike.c	/^int main(int argc, char *argv[])$/;"	f
max_iter	amoeba.c	/^const int max_iter = 50000;$/;"	v
max_iter	simplex.c	/^const int max_iter = 75000;$/;"	v
maximize	input_like.h	/^	int maximize;				\/\/ whether to maximize the likelihood$/;"	m
min_tips	input_sim.h	/^	int min_tips;				\/\/ number of tips a tree must have to be counted$/;"	m
n_param	nodes.h	/^	int n_param;$/;"	m
n_tips	likelihood-sdd.h	/^	int n_tips;$/;"	m	struct:st1i
n_tips	nodes.h	/^	int n_tips;			\/\/ # of tips (# of internal nodes = n_tips-1)$/;"	m
name	nodes.h	/^	char *name;$/;"	m
newKeyValue	keyvalue.c	/^struct KeyValue *newKeyValue()$/;"	f
next	nodes.h	/^	struct bnode *next;		\/\/ the next node on the broken branch$/;"	m	struct:bnode
node_counter	build.c	/^int node_counter;			\/\/ keep track of number of nodes in the tree$/;"	v
node_times	nodes.h	/^	double *node_times;		\/\/ can point to an array containing node times$/;"	m
nodes	tree_funcs.h	/^TreeNode *nodes, **downPassSequence;$/;"	v
nparms	keyvalue.h	/^	int nparms;$/;"	m	struct:KeyValue
num_start	input_sim.h	/^	int num_start;				\/\/ number at which to start labeling output files$/;"	m
num_trees	input_sim.h	/^	int num_trees;				\/\/ number of trees to simulate$/;"	m
param	input_like.h	/^	double param[6];			\/\/ so far, only two are used...$/;"	m
plot_like	input_like.h	/^	int plot_like;				\/\/ whether to make files for plotting the likelihood surface$/;"	m
prev	nodes.h	/^	struct bnode *prev;		\/\/ the previous node on the broken branch$/;"	m	struct:bnode
printKeyValue	keyvalue.c	/^void printKeyValue(const struct KeyValue *p)$/;"	f
reconstruct	input_like.h	/^	int reconstruct;			\/\/ whether to reconstruct ancestral states (if like_func = prune)$/;"	m
right	nodes.h	/^	struct tnode *left, *right, *anc;$/;"	m	struct:tnode
root	nodes.h	/^	TreeNode *root;$/;"	m
root_state	input_sim.h	/^	int root_state;			\/\/ character state of the root species$/;"	m
s2	likelihood-sdd.h	/^	int s2;$/;"	m	struct:st1i
segprob	nodes.h	/^	double segprob[2][2];	\/\/ segment probabilities$/;"	m	struct:bnode
st1i	likelihood-sdd.h	/^typedef struct st1i$/;"	s
start_t	nodes.h	/^	double start_t;		\/\/ time of root$/;"	m
swap	amoeba.c	/^static void swap(double *a, double *b)$/;"	f	file:
swap	simplex.c	/^static void swap(double *a, double *b)$/;"	f	file:
targets	Makefile	/^targets = SimTreeSDD TreeLike SDD-MCMC PruneTree NodeAges CompositePruneTree CountTips AvgBranchLength EstimateBeta PruneTree2$/;"	m
time	nodes.h	/^	double time, length;$/;"	m	struct:tnode
time	nodes.h	/^	double time;			\/\/ time of an internal node$/;"	m	struct:bnode
tnode	nodes.h	/^typedef struct tnode$/;"	s
trait	nodes.h	/^	int index, trait;$/;"	m	struct:tnode
trait	nodes.h	/^	int trait;			\/\/ state of the node$/;"	m	struct:bnode
trait_type	input_sim.h	/^	int trait_type;			\/\/ binary character (0) or region (1)$/;"	m
transition	input_sim.h	/^	double transition[2];		\/\/ transition rates {0->1, 1->0}$/;"	m
try_vertex	simplex.c	/^static double try_vertex(double simplex[][MAX_PARAM], double y[], double simsum[], double (*func)(TreeInfo *, double []), TreeInfo *tree, int ihi, double fac)$/;"	f	file:
uniform_distribution	randist.c	/^double uniform_distribution(double min, double max)$/;"	f
use_fixed_param	input_like.h	/^	int use_fixed_param;		\/\/ whether to get the likelihood and anc. states for given parameter values$/;"	m
value	keyvalue.h	/^	char *value[KV_MAXPARMS];$/;"	m	struct:KeyValue
verbosity	input_like.h	/^	int verbosity;				\/\/ how much stuff to print to the screen$/;"	m
verbosity	input_sim.h	/^	int verbosity;				\/\/ how much stuff to print to screen (0, 1, 2)$/;"	m
verbosity	output.c	/^int verbosity;$/;"	v
write_bmstrait	input_sim.h	/^	int write_bmstrait;$/;"	m
write_newick	input_sim.h	/^	int write_newick;			\/\/ output files to create$/;"	m
write_nexus	input_sim.h	/^	int write_nexus;$/;"	m
write_ttn	input_sim.h	/^	int write_ttn;$/;"	m
